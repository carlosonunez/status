package source

import (
	"bytes"
	"fmt"
	"regexp"
	"sort"
	"strings"
	"text/template"
	"time"

	v1 "github.com/carlosonunez/status/api/v1"
	"github.com/carlosonunez/status/pkg/v1/interfaces"
	"github.com/carlosonunez/status/pkg/v1/registry"
	log "github.com/sirupsen/logrus"
)

// DefaultTransformEventTimeoutSeconds is whatever it says below.
var DefaultTransformEventTimeoutSeconds = 10.0
var oneSecondInMillis = 1000.0

// ValidateEventRuleFn is an alias to ValidateEventRule.
var ValidateEventRuleFn = ValidateEventRule

// TransformEventTimeoutSeconds is the length of time to give template
// transformations before cutting them off.
var TransformEventTimeoutSeconds = DefaultTransformEventTimeoutSeconds

// NewSourceFromCfg creates an instance of a source.
func NewSourceFromCfg(cfg *v1.Source) (*interfaces.Source, error) {
	s, err := registry.LocateSource(cfg)
	if err != nil {
		return nil, err
	}
	return s, nil
}

// FetchAndPublishEvents retrieves events for a registered source and publishes
// them into a registered pub-sub.
//
// NOTE: An error occurring inside of FetchAndPublishEvents will not stop
// the main poll loop, as errors during polling are assumed to be eventually
// recoverable. However, an exponential backoff will be applied to prevent
// storms.
func FetchAndPublishEvents(s interfaces.Source, ps interfaces.PubSub) error {
	start := time.Now()
	pollDuration, _ := time.ParseDuration(s.GetParent().Settings.PollDuration)
	end := start.Add(pollDuration)
	evts, err := s.Poll(&start, &end)
	if err != nil {
		log.Errorf("poll failed for '%s': %s", s.GetParent().Name, err)
		return nil
	}
	log.Debugf("num events from '%s': %d", s.GetParent().Name, len(*evts))
	if len(*evts) == 0 {
		log.Debugf("zero events returned by '%s'; exiting", s.GetParent().Name)
		return nil
	}
	evtToPublish, transformList := selectFirstMatchingEvent(&s.GetParent().StatusGeneratingEvents, evts)
	if evtToPublish == nil {
		log.Infof("'%s': no events found during this poll", s.GetParent().Name)
		return nil
	}
	if err = TransformEvent(s, evtToPublish, transformList); err != nil {
		log.Debugf("failed to transform evt in '%s': %s", s.GetParent().Name, err)
		return err
	}
	evtsToPublish := []v1.Event{*evtToPublish}
	log.Debugf("%s: publishing event: %+v", s.GetParent().Name, evtsToPublish)
	return PushEvents(&evtsToPublish, ps)
}

func selectFirstMatchingEvent(defs *[]v1.StatusGeneratingEvent, evts *[]*v1.Event) (*v1.Event, *[]v1.EventTransform) {
	defsp := *defs
	sort.SliceStable(defsp, func(i, j int) bool {
		return defsp[i].Weight <= defsp[j].Weight
	})
	for _, def := range *defs {
		rules := def.IncludeIf
		for _, evt := range *evts {
			res, err := TestEvent(evt, &rules)
			if err != nil {
				log.Warningf("error in testing event '%s' against event def '%s': %s",
					evt.Message, def.Name, err)
			}
			if res {
				return evt, &def.Transforms
			}
		}
	}
	log.Debugf("no events found that match definitions %+v", *defs)
	return nil, nil
}

// ValidateSource checks that a source defined in a config is correct.
// This is done during status initialization before the source poll loop.
// We fail hard if a source is not defined to prevent statuses not getting set
// due to invalid configs.
func ValidateSource(s *v1.Source) error {
	err := validateStatusGeneratingEvents(s)
	if err != nil {
		return err
	}
	err = validateSourcePollDuration(s)
	if err != nil {
		return err
	}
	err = validateLockDurations(s)
	if err != nil {
		return err
	}
	return nil
}

func validateStatusGeneratingEvents(s *v1.Source) error {
	for _, e := range s.StatusGeneratingEvents {
		for _, r := range e.IncludeIf {
			if err := ValidateEventRuleFn(&r); err != nil {
				return fmt.Errorf("'%s' in event '%s' in source '%s' is an invalid event rule: '%s'",
					r.RuleType, e.Name, s.Name, err)
			}
		}
	}
	return nil
}

func validateSourcePollDuration(s *v1.Source) error {
	if _, err := time.ParseDuration(s.Settings.PollDuration); err != nil {
		return fmt.Errorf("poll duration for '%s' invalid: %s", s.Name, err)
	}
	return nil
}

func validateLockDurations(s *v1.Source) error {
	for _, ld := range s.Settings.LockDurations {
		if _, err := time.ParseDuration(ld.DefaultDuration); err != nil {
			return fmt.Errorf("default lock duration for '%s' invalid: %s", s.Name, err)
		}
		for _, ex := range ld.Exceptions {
			if _, err := time.ParseDuration(ex.Duration); err != nil {
				return fmt.Errorf("lock duration for receiver '%s' in source '%s' invalid: %s",
					ex.ReceiverName, s.Name, err)
			}
		}
	}
	return nil
}

// ValidateEventRule validates an event rule.
func ValidateEventRule(r *v1.EventIncludeRule) error {
	for _, er := range registry.RegisteredEventRules {
		if strings.ToLower(r.Rule) == strings.ToLower(er.Name) {
			return nil
		}
	}
	return fmt.Errorf("'%s' does not have an accompanying registered event rule", r.Rule)
}

// TestEvent tests that an event generated by a status satisfies a rule inside
// of a rule set.
func TestEvent(evt *v1.Event, rs *[]v1.EventIncludeRule) (bool, error) {
	resultMap := make(map[string]chan bool, len(*rs))
	for _, r := range *rs {
		found, err := registry.LocateEventRule(&r)
		if err != nil {
			return false, err
		}
		result := make(chan bool)
		resultMap[r.Rule] = result

		go runTestForEvent(result, evt, &r, found)
	}
	for _, v := range resultMap {
		res := <-v
		if res {
			return true, nil
		}
	}
	return false, nil
}

// TransformEvent recursively modifies an event payload with an updated version of a message
// based on a template. Template execution must complete within ten seconds.
func TransformEvent(src interfaces.Source, evt *v1.Event, ts *[]v1.EventTransform) error {
	res := make(chan error, 1)
	var duration int
	var unit time.Duration
	if TransformEventTimeoutSeconds <= 1 {
		duration = int(TransformEventTimeoutSeconds * oneSecondInMillis)
		unit = time.Millisecond
	} else {
		duration = int(TransformEventTimeoutSeconds)
		unit = time.Second
	}
	go func() {
		res <- doTransform(src, evt, ts)
	}()
	select {
	case err := <-res:
		return err
	case <-time.After(time.Duration(duration) * unit):
		return fmt.Errorf("transform exceeded %d%s deadline", duration, unit.String()[1:])
	}
}

// PushEvents pushes a batch of events into a pub-sub concurrently.
func PushEvents(evts *[]v1.Event, ps interfaces.PubSub) error {
	resultMap := make(map[string]chan map[string]error, len(*evts))
	for _, evt := range *evts {
		result := make(chan error)

		go func(e v1.Event) {
			m := make(map[string]error)
			err := ps.Publish("all-receivers", &e)
			m[e.Message] = err
			result <- err
		}(evt)
	}
	for _, v := range resultMap {
		m := <-v
		for msg, err := range m {
			if err != nil {
				return fmt.Errorf("'%s' couldn't be posted: %s", msg, err)
			}
		}
	}
	return nil
}

func doTransform(src interfaces.Source, evt *v1.Event, ts *[]v1.EventTransform) error {
	if len(*ts) == 0 {
		return nil
	}
	tsp := *ts
	t := tsp[0]
	type transformTemplateContext struct {
		Message       string
		CaptureGroups []string
		Source        *interfaces.Source
	}
	captureGroups := gatherStringsThatMatchInput(t.Input, evt.Message)
	if len(captureGroups) == 0 && strings.Contains(t.Template, "{{ index .CaptureGroups") {
		log.Warningf("transform '%s' references CaptureGroups, but none were found in this message"+
			"; returning unmodified: '%s'", t.Input, evt.Message)
		return nil
	}
	tmpl, err := template.New("tmpl").Parse(t.Template)
	if err != nil {
		log.Errorf("template parse failed; stopping transform: '%s'", t.Template)
		return err
	}
	var msg bytes.Buffer
	cxt := transformTemplateContext{
		CaptureGroups: captureGroups,
		Source:        &src,
		Message:       evt.Message,
	}
	err = tmpl.Execute(&msg, cxt)
	if err != nil {
		log.Errorf("template exec failed; stopping transform: '%s'", t.Template)
		return err
	}
	evt.Message = msg.String()
	tail := tsp[1:]
	return TransformEvent(src, evt, &tail)
}

func runTestForEvent(res chan bool, evt *v1.Event, er *v1.EventIncludeRule, r *v1.EventRule) {
	res <- r.Evaluator(evt.Message, er.Rule)
}

func gatherStringsThatMatchInput(p string, s string) []string {
	var captures []string
	re, err := regexp.Compile(p)
	if err != nil {
		return captures
	}
	matches := re.FindAllStringSubmatch(s, -1)
	if len(matches) != 1 {
		return captures
	}
	matchesExceptOriginalString := matches[0][1:]
	for _, match := range matchesExceptOriginalString {
		captures = append(captures, match)
	}
	return captures
}
